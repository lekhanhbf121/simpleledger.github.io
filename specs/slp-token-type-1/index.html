<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SLP Token Type 1 Protocol Specification</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#3a0839">
    <link rel="shortcut icon" href="/favicon.ico"><link rel='canonical' href='https://slp.dev/specs/slp-token-type-1/'/>
    <meta name="description" content="">
    <meta property="article:modified_time" content="2020-06-17T00:07:04.000Z">
    <meta property="og:title" content="SLP Token Type 1 Protocol Specification">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://slp.dev/specs/slp-token-type-1/">
    <meta property="og:image" content="https://slp.dev/logo.png">
    <meta name="twitter:title" content="SLP Token Type 1 Protocol Specification">
    <meta name="twitter:url" content="https://slp.dev/specs/slp-token-type-1/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://slp.dev/logo.png">
    <meta name="image" content="https://slp.dev/logo.png">
    <meta name="msapplication-TileColor" content="#3a0839">
    <meta name="msapplication-config" content="/browserconfig.xml">
    <meta name="theme-color" content="#5bbad5">
    
    <link rel="preload" href="/assets/css/0.styles.a2612fed.css" as="style"><link rel="preload" href="/assets/js/app.727bd0bc.js" as="script"><link rel="preload" href="/assets/js/2.59409279.js" as="script"><link rel="preload" href="/assets/js/6.cb6c63cc.js" as="script"><link rel="preload" href="/assets/js/5.276ce48f.js" as="script"><link rel="prefetch" href="/assets/js/10.11bd2d6f.js"><link rel="prefetch" href="/assets/js/11.3448a0e0.js"><link rel="prefetch" href="/assets/js/12.5390e135.js"><link rel="prefetch" href="/assets/js/13.25949c46.js"><link rel="prefetch" href="/assets/js/14.8adf2b39.js"><link rel="prefetch" href="/assets/js/15.f57aebe1.js"><link rel="prefetch" href="/assets/js/16.a9988494.js"><link rel="prefetch" href="/assets/js/17.b632b9c1.js"><link rel="prefetch" href="/assets/js/18.579a7df4.js"><link rel="prefetch" href="/assets/js/19.07b36477.js"><link rel="prefetch" href="/assets/js/20.34496b79.js"><link rel="prefetch" href="/assets/js/21.aa9572ce.js"><link rel="prefetch" href="/assets/js/22.f611c7a9.js"><link rel="prefetch" href="/assets/js/23.fb176ab4.js"><link rel="prefetch" href="/assets/js/24.ae34a08d.js"><link rel="prefetch" href="/assets/js/25.a4764520.js"><link rel="prefetch" href="/assets/js/26.38ce89a0.js"><link rel="prefetch" href="/assets/js/27.b1edb44d.js"><link rel="prefetch" href="/assets/js/28.9dd2f0e6.js"><link rel="prefetch" href="/assets/js/29.b7ec60f2.js"><link rel="prefetch" href="/assets/js/3.8e11cb09.js"><link rel="prefetch" href="/assets/js/30.b3de8cee.js"><link rel="prefetch" href="/assets/js/31.71a279fa.js"><link rel="prefetch" href="/assets/js/32.5bad9125.js"><link rel="prefetch" href="/assets/js/33.29483670.js"><link rel="prefetch" href="/assets/js/34.42841138.js"><link rel="prefetch" href="/assets/js/35.b99d13bf.js"><link rel="prefetch" href="/assets/js/36.3ce31b1a.js"><link rel="prefetch" href="/assets/js/37.c0523623.js"><link rel="prefetch" href="/assets/js/38.f40e6826.js"><link rel="prefetch" href="/assets/js/39.690a7325.js"><link rel="prefetch" href="/assets/js/4.e08ed9f2.js"><link rel="prefetch" href="/assets/js/40.e3acd5f1.js"><link rel="prefetch" href="/assets/js/41.da4e1119.js"><link rel="prefetch" href="/assets/js/42.f9a30f27.js"><link rel="prefetch" href="/assets/js/43.7f8a50cc.js"><link rel="prefetch" href="/assets/js/44.8e978a53.js"><link rel="prefetch" href="/assets/js/45.92a7fe60.js"><link rel="prefetch" href="/assets/js/46.0072c31d.js"><link rel="prefetch" href="/assets/js/47.d0b4a172.js"><link rel="prefetch" href="/assets/js/48.56897b92.js"><link rel="prefetch" href="/assets/js/49.01e5e0b1.js"><link rel="prefetch" href="/assets/js/50.e5c0199d.js"><link rel="prefetch" href="/assets/js/51.a3b63ce1.js"><link rel="prefetch" href="/assets/js/52.c689335b.js"><link rel="prefetch" href="/assets/js/53.27b0e617.js"><link rel="prefetch" href="/assets/js/54.90baf352.js"><link rel="prefetch" href="/assets/js/55.75e41a49.js"><link rel="prefetch" href="/assets/js/56.0f4c2dcd.js"><link rel="prefetch" href="/assets/js/57.9fa9f121.js"><link rel="prefetch" href="/assets/js/58.278c7677.js"><link rel="prefetch" href="/assets/js/59.e147c217.js"><link rel="prefetch" href="/assets/js/60.21d56b27.js"><link rel="prefetch" href="/assets/js/61.a94ff6cf.js"><link rel="prefetch" href="/assets/js/62.cfc1d4fb.js"><link rel="prefetch" href="/assets/js/63.ecb1ff64.js"><link rel="prefetch" href="/assets/js/64.5f630325.js"><link rel="prefetch" href="/assets/js/65.29333f2d.js"><link rel="prefetch" href="/assets/js/66.07e30d95.js"><link rel="prefetch" href="/assets/js/67.f1a6158d.js"><link rel="prefetch" href="/assets/js/68.e90e7a5e.js"><link rel="prefetch" href="/assets/js/7.0ad4cf60.js"><link rel="prefetch" href="/assets/js/8.3cd91f71.js"><link rel="prefetch" href="/assets/js/9.14c39fac.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a2612fed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/slp-documentation-logo.svg" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/get-started/" class="sidebar-link">Get Started</a></li><li><a href="/terminology/" class="sidebar-link">Terminology</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Specifications</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/specs/slp-token-type-1/" aria-current="page" class="active sidebar-link">Token Type 1</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#authors" class="sidebar-link">Authors</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#acknowledgements" class="sidebar-link">Acknowledgements</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#introduction" class="sidebar-link">Introduction</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#summary" class="sidebar-link">Summary</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#use-cases" class="sidebar-link">Use Cases</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#requirements" class="sidebar-link">Requirements</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#comparison-to-other-token-schemes" class="sidebar-link">Comparison to other token schemes</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#design-philosophy-and-challenges" class="sidebar-link">Design Philosophy and Challenges</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#protocol-overview" class="sidebar-link">Protocol Overview</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#consensus-model" class="sidebar-link">Consensus Model</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#checksum-commitments" class="sidebar-link">Checksum commitments</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#consensus-rules" class="sidebar-link">Consensus Rules</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#transaction-detail" class="sidebar-link">Transaction Detail</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#slp-addr" class="sidebar-link">SLP Addr</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#wallet-implementation" class="sidebar-link">Wallet Implementation</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#proxies" class="sidebar-link">Proxies</a></li><li class="sidebar-sub-header"><a href="/specs/slp-token-type-1/#economic-implications" class="sidebar-link">Economic Implications</a></li></ul></li><li><a href="/specs/slp-nft-1/" class="sidebar-link">NFT1</a></li><li><a href="/specs/slp-payment-protocol/" class="sidebar-link">Payment Protocol</a></li><li><a href="/specs/slp-postage-protocol/" class="sidebar-link">Postage Protocol</a></li><li><a href="/specs/slp-uri-scheme/" class="sidebar-link">URI Scheme</a></li><li><a href="/specs/bitcoinfiles/" class="sidebar-link">Bitcoin Files</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Guides</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Packages</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Tooling</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/community/" class="sidebar-link">Community</a></li></ul> </aside> <main class="page" data-v-4c735fbc> <div class="theme-default-content content__default" data-v-4c735fbc><h1 id="slp-token-type-1-protocol-specification"><a href="#slp-token-type-1-protocol-specification" class="header-anchor">#</a> SLP Token Type 1 Protocol Specification</h1> <h4 id="version-0-3"><a href="#version-0-3" class="header-anchor">#</a> Version: 0.3</h4> <h4 id="date-published-august-21-2018"><a href="#date-published-august-21-2018" class="header-anchor">#</a> Date published: August 21, 2018</h4> <p></p><div class="table-of-contents"><ul><li><a href="#authors">Authors</a></li><li><a href="#acknowledgements">Acknowledgements</a></li><li><a href="#introduction">Introduction</a></li><li><a href="#summary">Summary</a></li><li><a href="#use-cases">Use Cases</a></li><li><a href="#requirements">Requirements</a></li><li><a href="#comparison-to-other-token-schemes">Comparison to other token schemes</a></li><li><a href="#design-philosophy-and-challenges">Design Philosophy and Challenges</a><ul><li><a href="#simplicity-and-consensus">Simplicity and Consensus</a></li><li><a href="#why-spv-friendly-permissionless-tokens-are-difficult">Why SPV-friendly permissionless tokens are difficult</a></li><li><a href="#hybrid-security-model">Hybrid Security Model</a></li></ul></li><li><a href="#protocol-overview">Protocol Overview</a></li><li><a href="#consensus-model">Consensus Model</a></li><li><a href="#checksum-commitments">Checksum commitments</a></li><li><a href="#consensus-rules">Consensus Rules</a><ul><li><a href="#rules-for-transfer-transactions-send">Rules for transfer transactions (SEND)</a></li><li><a href="#rules-for-issuance-transactions-genesis-mint">Rules for issuance transactions (GENESIS/MINT)</a></li><li><a href="#considerations">Considerations</a></li></ul></li><li><a href="#transaction-detail">Transaction Detail</a><ul><li><a href="#formatting">Formatting</a></li><li><a href="#genesis-token-genesis-transaction">GENESIS - Token Genesis Transaction</a></li><li><a href="#mint-extended-minting-transaction">MINT - Extended Minting Transaction</a></li><li><a href="#send-spend-transaction">SEND - Spend Transaction</a></li><li><a href="#commit-checksum-commitment-transaction">COMMIT - Checksum Commitment Transaction</a></li><li><a href="#examples">Examples</a></li></ul></li><li><a href="#slp-addr">SLP Addr</a></li><li><a href="#wallet-implementation">Wallet Implementation</a><ul><li><a href="#balance-and-history">Balance and History</a></li><li><a href="#token-safety">Token Safety</a></li><li><a href="#funding-transaction-fees">Funding Transaction Fees</a></li><li><a href="#sending-and-receiving">Sending and Receiving</a></li><li><a href="#handling-multiple-token-types">Handling multiple token types</a></li><li><a href="#token-names">Token names</a></li><li><a href="#validation-in-light-wallets">Validation in Light Wallets</a></li></ul></li><li><a href="#proxies">Proxies</a><ul><li><a href="#tokengraph">Tokengraph</a></li></ul></li><li><a href="#economic-implications">Economic Implications</a></li></ul></div><p></p> <h2 id="authors"><a href="#authors" class="header-anchor">#</a> Authors</h2> <p>Jonald Fyookball, James Cramer, Unwriter, Mark B. Lundeberg, Calin Culianu, Ryan X. Charles</p> <h2 id="acknowledgements"><a href="#acknowledgements" class="header-anchor">#</a> Acknowledgements</h2> <p>Amaury Sechet, for suggesting merklix based hash committments</p> <p>Andrew Stone, for the token descriptor and baton ideas</p> <p>Dexx7, for code review and ideas</p> <h1 id="section-i-background"><a href="#section-i-background" class="header-anchor">#</a> SECTION I: BACKGROUND</h1> <h2 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h2> <p>We begin with the premise that Bitcoin Cash needs a system for handling tradable or redeemable tokens.  We base this premise on the myriad of possible use cases and the billions of dollars of market capitalization that currently exist on platforms such as Ethereum.</p> <p>Despite the demand, enhancement proposals such as GROUP or OP_GROUP have not achieved enough consensus to meet the high bar required for changing the Bitcoin Cash base protocol layer.  Nor have there been any non-protocol proposals with sufficient traction.</p> <p>Therefore, we are motivated to present our own solution.  The key to its potential success lies in its simplicity, but will also depend on our taking action to foster the support of the ecosystem.</p> <h2 id="summary"><a href="#summary" class="header-anchor">#</a> Summary</h2> <p>Simple Ledger Protocol (SLP) uses the meta data in OP_RETURN for the issuance and transfer of tokens in conjunction with standard transaction outputs that each represent a number of token units specified by the sender. Consensus on the interpretation of the OP_RETURN outputs is achieved by token users and market participants adhering to a prescribed set of simple rules.</p> <p>Because SLP builds on the transaction chain of the existing Bitcoin framework, users can easily verify transactions with SPV/light wallets within practical boundaries.  Full validation of a transaction back to its token genesis is possible by supplementing existing transaction-retrieval infrastructure with integration of SLP consensus rules.</p> <h2 id="use-cases"><a href="#use-cases" class="header-anchor">#</a> Use Cases</h2> <p>A plethora of use cases for tokens has been detailed by others and does not require a long discussion here.   Uses include stocks, securities, registries, smart properties, utility tokens, contracts, coupons, bonds, demand deposits, local currencies, representation of physical assets, and many more.</p> <h2 id="requirements"><a href="#requirements" class="header-anchor">#</a> Requirements</h2> <p>We believe that a good solution for implementing tokens should have the following properties:</p> <p><strong>1. Permissionless</strong>. Its tokens should not require permission to issue or transfer.<br> <strong>2. Simple</strong>. The system should be easily understandable and straightforward.<br> <strong>3. Robust.</strong> A minimal, unambiguous rule set supports a fault-tolerant consensus layer.<br> <strong>4. Non-invasive.</strong> It should require no changes to the underlying Bitcoin Cash protocol.<br> <strong>5. SPV friendly.</strong> Users of light wallets should be able to validate their own transactions.<br> <strong>6. Extensible.</strong> The system should allow future versions of tokens including tokens with issuer controlled whitelists for regulated securities (<a href="#appendix-a-regulated-security-tokens">Appendix A</a>), and other needs.<br> <strong>7. Supported.</strong> There should be an implementation plan for rapid ecosystem support.</p> <h2 id="comparison-to-other-token-schemes"><a href="#comparison-to-other-token-schemes" class="header-anchor">#</a> Comparison to other token schemes</h2> <p>Before presenting the details of our proposal, it may be helpful to review previous and competing proposals.</p> <p>In a perfect world, miners would validate tokens transactions, bringing the full Bitcoin security model to tokens.  However, this would require a protocol change like with the GROUP proposal.    Alternatively, a different kind of protocol change would allow a trustless linkage to flexible side-chains (such as RSK) upon which tokens may be built.</p> <p>Absent miner-validation of tokens, it is necessary to add extra data onto ordinary  transactions that indicates coloring, transferred value, etc. The standard way to do this is with <a href="https://en.bitcoin.it/wiki/Script#Provably_Unspendable.2FPrunable_Outputs" target="_blank" rel="noopener noreferrer">OP_RETURN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> which allows cleanly holding arbitrary data. Unfortunately, any bitcoin user can post an apparent token-transfer transaction and have it confirmed by miners without actually owning tokens. Token conservation and any other desired rules must instead be enforced with user consensus alone, by examining the history behind each transaction and marking as ‘invalid’ those that do not follow the rules of its protocol.</p> <p>Many implementations (including this proposal) fall under the category of &quot;colored coins&quot;.   <a href="https://github.com/Colored-Coins/Colored-Coins-Protocol-Specification/wiki/Faq#coloring-satoshis" target="_blank" rel="noopener noreferrer">Most of these designs actually supplement the transaction output (UTXO) with extra colored values<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>: Surprisingly, only EPOBC (one of the earliest proposals) actually took bitcoins and applied color to them.</p> <p>The advantage of these &quot;colored coin&quot; tokens is that the miners prevent double-spending. One disadvantage is that these UTXOs can be accidentally spent without the special color metadata, which is equivalent to discarding the tokens. This easily occurs if tokens are sent to someone with a regular (non-token-aware) bitcoin wallet. <a href="https://github.com/chromaway/ngcccbase/wiki/Addresses" target="_blank" rel="noopener noreferrer">Color addresses<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> have been proposed to reduce these accidents.</p> <p>Finally, some token schemes (Omni, Counterparty) discard the UTXO concept for tokens and instead associate an overall balance to an address. Transactions then serve only as a signed and irreversibly published order of balance transfer, and miners do not prevent double-spending of tokens. Users’ checking of transaction validity requires examining all prior transactions associated with the addresses involved, and this is sensitive to blockchain re-ordering. The <a href="https://en.wikipedia.org/wiki/Tether_(cryptocurrency)" target="_blank" rel="noopener noreferrer">Tether<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> USD-pegged token was issued on Omni.</p> <p>Since colored coins cannot be double spent, <a href="https://www.reddit.com/r/Bitcoin/comments/26mzbb/chromawallet_colored_coins_v007_beta_it/chsm1na/" target="_blank" rel="noopener noreferrer">one can prove<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> the validity of a token transaction by examining only the input ancestor transactions tracing back to when the tokens were first minted. This set of transactions forms a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="noopener noreferrer">directed acyclic graph<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> (DAG). These proofs are significantly more weighty than SPV, yet still simple enough to implement in a lite client. In contrast, balance-based tokens in principle require a full node to achieve a high level of security: only after an examination of all transactions (to ensure inclusion of all at a given address), can valid transactions be proven.</p> <p>Token implementations also vary in their scriptability, ranging from none at all (tokens can only be sent and received), to bitcoin-level (multisig, atomic swaps, payment channels possible), up to highly complex scripting languages like those implemented on the Ethereum cryptocurrency.</p> <p>Here is a chart comparing primary token properties:
<img src="/assets/img/table1.4c46db4d.png" alt="Table 1"></p> <p>Other aspects are noted below: how multiple tokens can interact (e.g., can they appear in the same transaction, allowing token-token direct swaps?); how much customization is available to token properties at issuance; and any other notable extras / unusual features.</p> <p><img src="/assets/img/table2.f9622917.png" alt="Table 2"></p> <h2 id="design-philosophy-and-challenges"><a href="#design-philosophy-and-challenges" class="header-anchor">#</a> Design Philosophy and Challenges</h2> <p>Understanding the thinking behind the SLP protocol may assist in its evaluation.</p> <h3 id="simplicity-and-consensus"><a href="#simplicity-and-consensus" class="header-anchor">#</a> Simplicity and Consensus</h3> <p>Our most formative principle is that of simplicity.  We found most of the previous attempts to introduce Bitcoin token proposals to be overcomplicated, which hinders both community support as well as implementation efforts and integration.</p> <p>But there is an even more important reason to keep things as simple as possible, and that is to facilitate consensus.  The base layer of Bitcoin can accommodate a complex set of consensus rules because Proof-of-Work ensures high byzantine fault tolerance.  In other words, if miners’ implementations do not agree, the incompatibility is revealed quickly and the non-integrous data is expunged.</p> <p>By contrast, meta data is not miner validated and there is no clear separation between valid and invalid data.  This creates an environment of low fault tolerance.  For token schemes that rely on central authorities or signers, this is not necessarily an issue.  However, for permissionless systems like SLP, the only apparent way to mitigate this problem is to keep the rules simple and clear.</p> <h3 id="why-spv-friendly-permissionless-tokens-are-difficult"><a href="#why-spv-friendly-permissionless-tokens-are-difficult" class="header-anchor">#</a> Why SPV-friendly permissionless tokens are difficult</h3> <p>Without modifying the base Bitcoin protocol, supporting SPV wallets is challenging.  This is because invalid Bitcoin transactions are excluded from the blockchain, but invalid second-layer transactions are not.  Thus, you cannot use the SPV security technique of checking the merkle branch to ensure the transaction is included in a block.</p> <p>To prove a token transfer is valid, it is necessary to validate all prior transfers starting with the token genesis.  It would be advantageous to validate a token transaction with a high degree of certainty using only a subset of prior transactions.  Unfortunately, this does not appear possible because an attacker can cheaply create a chain of transactions to fool a recipient into believing an incoming transaction is valid when it is not.</p> <p>We considered the possibility of attempting to prevent this attack with various commitment schemes, requiring transactions to point back to prior transactions.  However, this idea is ineffective because all links can be spoofed, regardless of whether they pointed to fake transactions on the false chain or real transactions on the valid chain. Thus, foul play would only be detectable at the exact place of divergence, which could be anywhere.</p> <h3 id="hybrid-security-model"><a href="#hybrid-security-model" class="header-anchor">#</a> Hybrid Security Model</h3> <p>Other various commitment schemes were considered and discarded.  Finally, we concluded that the simplest solution is best:  Users can validate the transfer of token ownership as far back as they choose, with the understanding that if they do not verify completely then it is theoretically possible for an attacker to create a longer attack chain.</p> <p>It is an acceptable limitation to have partial SPV-compatible validation, IF it is supplemented with an infrastructure-based solution providing full validation.  We will discuss the security model in detail in a subsequent section.</p> <h1 id="section-ii-protocol-description"><a href="#section-ii-protocol-description" class="header-anchor">#</a> SECTION II: PROTOCOL DESCRIPTION</h1> <h2 id="protocol-overview"><a href="#protocol-overview" class="header-anchor">#</a> Protocol Overview</h2> <p>The protocol defines 4 types of token transactions, which are contained within the OP_RETURN meta data of standard Bitcoin Cash transactions.</p> <p>The first 2 token transaction types (genesis and extended minting) define and issue the token.  The third transaction type is the most common (send); it allows users to transfer tokens.
The final transaction type (checksum commitment) is a supplement to the basic consensus model.</p> <p>Like most &quot;colored coins&quot; protocols, SLP associates token amounts with real BCH transaction outputs, but with a token amount that is independent from the BCH amount.  Since Bitcoin transactions usually have multiple outputs, the OP_RETURN message specifies how many tokens are being assigned to which outputs.</p> <p>Besides defining a format for the OP_RETURN message, the protocol also defines consensus rules that determine the validity of a token send transaction or extended minting transaction  (see Consensus Rules section below).</p> <p>SLP transactions may contain multiple inputs and outputs which correspond to those in the Bitcoin transaction they are carried in (although it is possible to have additional <em>non</em>-SLP inputs and outputs in the same transaction).  Note that you cannot send multiple <em>types</em> of SLP tokens in the same transaction.  Also, it is possible to lose tokens if a token-containing output is improperly spent.</p> <h2 id="consensus-model"><a href="#consensus-model" class="header-anchor">#</a> Consensus Model</h2> <p>SLP utilizes a model that could be described as <strong>Proof-of-Work/Proof-of-Trust</strong>.</p> <p>Meta data, while prunable, is still part of Bitcoin blocks -- time-stamped and ordered in the immutable ledger via Proof-of-Work. However, like most OP_RETURN based approaches, what SLP sees as valid data is not segregated from what it considers invalid.  Although unambiguously ordered to prevent double-spending, the data must be filtered according to a set of rules that all participants agree on.</p> <p>In many ways, this is not different than how Bitcoin itself operates.  Users must stay together on the same set of consensus rules to maintain their network effect.  The possibility to diverge is always present, with the market being the ultimate judge of how much value each ruleset holds.</p> <p>In a pure Proof-of-Work model, byzantine fault tolerance is achieved via economic incentives combined with incompatible-by-design sets of data.  By contrast, SLP relies on a minimalistic set of rules overlayed onto the support of the PoW backbone.</p> <p>With transaction ordering taken care of by the underlying Bitcoin Cash blockchain, users simply have to use the same rules as a matter of convention. Those rules will be defined by the concordance of:</p> <p>a) this specification</p> <p>b) a reference implementation (Electron Cash SLP wallet)</p> <p>c) token issuers</p> <h2 id="checksum-commitments"><a href="#checksum-commitments" class="header-anchor">#</a> Checksum commitments</h2> <p>Token issuers and/or other trusted ecosystem participants should publish periodic hash commitments of valid transactions in accordance with this specification, which provides a &quot;Proof of Trust&quot;.</p> <p>It is important to understand that the checksums are part of the overall consensus model but are <strong>NOT</strong> part of the consensus <em>rules</em> per se.  If this sounds paradoxical, understand that the blockchain data and protocol rules are paramount.  The issuer is usually (but not always) just the most important economic actor.</p> <p>Commitments by the issuer or trusted validators serve as a &quot;proof of responsibility&quot;.  If the economic stakeholders are not capable of producing an accurate summary of transactions under the rules of the protocol, it will be readily apparent, and market forces will react appropriately.  As a side benefit, checksum commitments create a modest barrier to entry, delineating low-effort actors from more professional operations.</p> <h2 id="consensus-rules"><a href="#consensus-rules" class="header-anchor">#</a> Consensus Rules</h2> <p>In all cases of SLP transactions:</p> <ul><li><p>There must be an OP_RETURN output script in the first output (vout=0). An OP_RETURN output script is defined as a ScriptPubKey beginning with opcode 0x6a.</p></li> <li><p>This OP_RETURN first-output script holds an SLP message, whose contents must conform precisely to this specification (see &quot;transaction detail&quot; section).</p></li></ul> <h3 id="rules-for-transfer-transactions-send"><a href="#rules-for-transfer-transactions-send" class="header-anchor">#</a> Rules for transfer transactions (SEND)</h3> <ul><li><p>The sum of token outputs specified OP_RETURN may not exceed the sum of valid token inputs.
A 'valid token input' is a transaction input (i.e., a spent TXO) where the previous transaction is already known to conform to SLP consensus rules. The value of a valid token input is simply the token amount listed in the OP_RETURN SLP message of the transaction that created the TXO.</p></li> <li><p>Inputs of a differing <code>token_type</code> or <code>token_id</code> are to be ignored in this calculation, i.e., treated as if they contributed 0 tokens.</p></li></ul> <h3 id="rules-for-issuance-transactions-genesis-mint"><a href="#rules-for-issuance-transactions-genesis-mint" class="header-anchor">#</a> Rules for issuance transactions (GENESIS/MINT)</h3> <ul><li><p>GENESIS transactions are self-evidently valid or invalid, not relying on inputs' validity or content.</p></li> <li><p>MINTs require a special 'baton' input, either directly from the GENESIS that created it, or indirectly via a previous MINT. Inputs of a differing <code>token_type</code> or <code>token_id</code> are to be ignored in this calculation, i.e., treated as if they contributed no baton. Token inputs should also be ignored -- only the baton is relevant.</p></li></ul> <h3 id="considerations"><a href="#considerations" class="header-anchor">#</a> Considerations</h3> <p>A. It is in principle possible for a transaction to include multiple OP_RETURN output scripts (currently these are non-standard in bitcoin, but this may change). We emphasize that all other output scripts after vout=0 are irrelevant to SLP. Thus the secondary OP_RETURN scripts could, for example, be used to hold notes, or data for other protocols.</p> <p>B. It is possible for the number of token outputs not to match the number of transaction outputs, but this does not invalidate the transaction:</p> <ul><li>If the number of transaction outputs is greater than the number of token amounts specified in OP_RETURN, then the extra transaction outputs implicitly recieve 0 tokens.</li> <li>If the number of transactions outputs is less than the number of token amounts specified in OP_RETURN, the extra token amounts are simply burned. (note that these burned amounts are regardless included in the token output sum check)</li></ul> <p>C. It is possible for one or more inputs of a transaction to come from invalid or bogus SLP transactions; this does not invalidate the transaction, as those inputs are just ignored. As long as the consensus rules are met on the basis of valid inputs alone, then the transaction is valid.</p> <p>D. A token's genesis defines the protocol type (<code>token_type</code>) it is using.  This is less flexible than allowing &quot;soft forks&quot; of new rules, but prevents future problems. Although immutable, we still pass the version in each transaction to facilitate parsing and give unlimited flexibility in future SLP protocol types.</p> <p>E. In a send, the input-sum or output-sum may exceed 2<sup>64</sup>−1 (64-bit integer limit) even though all summands are 64-bit integers. Such excessive sums are valid and so validators should avoid using accumulators that overflow in these conditions.</p> <p>F. SENDs that output 0 tokens are a strange corner case that have self-evident validity, like genesis transactions. In the case of a 0-output SEND, it doesn't matter whether any of the inputs are valid. Also, the token_id may refer to a nonexistent transaction, or a real genesis but of a different token_type.</p> <h2 id="transaction-detail"><a href="#transaction-detail" class="header-anchor">#</a> Transaction Detail</h2> <h3 id="formatting"><a href="#formatting" class="header-anchor">#</a> Formatting</h3> <p>SLP uses a restricted form of bitcoin script after the OP_RETURN to encode variable length data chunks (byte arrays) as bitcoin script PUSH operations.  Each separately pushed chunk inside the OP_RETURN payload is denoted in the subsequent sections using angle brackets (e.g., &lt;xyz&gt;). Messages violating these rules shall be judged entirely invalid under SLP consensus:</p> <ol><li><p>The script must be valid bitcoin script. Each field must be preceded by a valid Bitcoin script data push opcode. Truncated scripts (ending mid-push) are disallowed.</p></li> <li><p>Each field presented inside the OP_RETURN payload must match the byte size and/or value indicated in parentheses.</p></li> <li><p>Bitcoin script allows a given byte array to be pushed in various ways, and we allow this in SLP as well. For example, it is valid to push a 4-byte chunk (like the Lokad ID) in four different ways: 0x04 [chunk], 0x4c 0x04 [chunk], 0x4d 0x04 0x00 [chunk], or 0x4e 0x04 0x00 0x00 0x00 [chunk].</p></li> <li><p>Only opcodes 0x01 to 0x4e are permitted (after OP_RETURN). Note this means that not all push opcodes are allowed -- it is forbidden to use the empty-push opcode 0x00 (OP_0) or 1-byte literal push opcodes 0x4f-0x60 (OP_1 through OP_16 and OP_1NEGATE) anywhere in the OP_RETURN. For example, it is invalid to use 0x58 to push the number '8' in the 1-byte decimals field of the GENESIS transaction, even though in normal bitcoin script the opcode 0x58 is effectively equivalent to 0x01 0x08  (push [0x08]). For this reason some standard bitcoin script decompilers, that treat all push opcodes on equal footing, must not be used for parsing SLP transactions.</p></li> <li><p>Some fields permit an empty push (length-0 chunk) however you cannot use opcode 0x00 for this purpose. Rather, you may use 0x4c 0x00, or 0x4d 0x00 0x00, or 0x4e 0x00 0x00 0x00 0x00.</p></li> <li><p>All integer fields are unsigned and use big-endian encoding, and must conform to the specified byte size range. For example, an amount of 1000 in an indicated 8-byte field shall be pushed as the byte array [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8].</p></li> <li><p>Optional fields are omitted by simply leaving out the push. If an optional field is included, all preceding optional fields must be included as well.</p></li> <li><p>Extraneous appendages are prohibited.  Any unexpected data coming after an otherwise-valid payload will invalidate the transaction.</p></li> <li><p>String fields within the GENESIS OP_RETURN payload have a recommended character encoding, however it is <em>not</em> required for validity that these byte arrays can be successfully decoded. String fields of (in principle) unlimited length are listed with an upper limit of &quot;∞&quot;, however in practice they are limited by the ScriptPubKey length restriction (223 bytes at the time of this writing).</p></li></ol> <p>We emphasize the point, again, that the message has to be perfect in its entirety. For example, if a transaction has 5 outputs, and the fifth output has only 7 bytes instead of 8, then the previous 4 outputs effectively burn the tokens because the entire transaction is invalid.</p> <h3 id="genesis-token-genesis-transaction"><a href="#genesis-token-genesis-transaction" class="header-anchor">#</a> GENESIS - Token Genesis Transaction</h3> <p>This is the first transaction which defines the properties, metadata and initial mint quantity of the token. The token is thereafter uniquely identified by the token genesis transaction hash which is referred to as <code>token_id</code>.</p> <p><code>token_type</code> indicates the SLP sub-protocol:</p> <ul><li>1 - Permissionless Token Type</li> <li>2 - Reserved for Security Token Type (see <a href="#appendix-a-regulated-security-tokens">Appendix A</a>)</li> <li>3 - Reserved for Voting Token Type</li> <li>4 - Reserved for Ticketing Token Type</li> <li>...</li></ul> <p>This document specifies the rules and operation of the Permissionless Token Type (1) only. Tokens of different types cannot be mixed, and so future specifications of other token types will not affect the consensus validity of type 1.</p> <p><code>mint_baton_vout</code>: Future token supply increases are made possible if the genesis endows a specific transaction output with a &quot;minting baton&quot; that can be passed along and used for future minting (using 'MINT' transactions, see below). If <code>mint_baton_vout</code> is not present or refers to a nonexistent output, then the baton does not exist and the token provably has a one-time issuance.</p> <p><code>decimals</code>: indicates that 1 token is divisible into 10^<code>decimals</code> base units. SLP messages store whole numbers indicating token amounts as measured in the base unit, analogous to how bitcoin transactions store BCH amounts measured in the base unit 'satoshis'. With a token FOO having <code>decimals</code> of 6 indicated in the genesis, for example, the quantity 12.53 FOO (as displayed in wallet software) would be represented by 12530000 base units (as 8 bytes, hex 0000000000bf3150). A <code>decimals</code> of 8 would give the same divisibility as bitcoin, whereas 0 would give indivisible tokens.</p> <p>The genesis transaction includes an initial minting of <code>initial_token_mint_quantity</code> base units, placed on the second transaction output (vout=1).</p> <p><strong>Transaction inputs</strong>: Any number of inputs or content of inputs, in any order.</p> <p><strong>Transaction outputs</strong>:</p> <table><thead><tr><th>v<sub>out</sub></th> <th>ScriptPubKey (&quot;Address&quot;)</th> <th>BCH amount</th> <th>Implied token amount (base units)</th></tr></thead> <tbody><tr><td>0</td> <td>OP_RETURN<br>&lt;lokad_id: 'SLP\x00'&gt; (4 bytes, ascii)<sup>1</sup><br>&lt;token_type: 1&gt; (1 to 2 byte integer)<br>&lt;transaction_type: 'GENESIS'&gt; (7 bytes, ascii)<br>&lt;token_ticker&gt; (0 to ∞ bytes, suggested utf-8)<br>&lt;token_name&gt; (0 to ∞ bytes, suggested utf-8)<br>&lt;token_document_url&gt; (0 to ∞ bytes, suggested ascii)<br>&lt;token_document_hash&gt; (0 bytes or 32 bytes)<br>&lt;decimals&gt; (1 byte in range 0x00-0x09)<br>&lt;mint_baton_vout&gt; (0 bytes, or 1 byte in range 0x02-0xff)<br>&lt;initial_token_mint_quantity&gt; (8 byte integer)<br></td> <td>any<sup>2</sup></td> <td>0</td></tr> <tr><td>1</td> <td>Initial mint receiver</td> <td>any<sup>2</sup></td> <td>initial_token_mint_quantity</td></tr> <tr><td>...</td> <td>Any</td> <td>any<sup>2</sup></td> <td>0</td></tr> <tr><td>M</td> <td>(M=mint_baton_vout) Mint baton receiver</td> <td>any<sup>2</sup></td> <td>0<br>+ 'baton'</td></tr> <tr><td>...</td> <td>Any</td> <td>any<sup>2</sup></td> <td>0</td></tr></tbody></table> <p><sup>1. The Lokad identifier is registered as the number 0x504c53 (which, when encoded in the 4-byte little-endian format expected for Lokad IDs, gives the ascii string 'SLP\x00'). Inquiries and additional information about the Lokad system of OP_RETURN protocol identifiers can be found at <a href="https://github.com/Lokad/Terab" target="_blank" rel="noopener noreferrer">https://github.com/Lokad/Terab<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> maintained by Joannes Vermorel.</sup></p> <p><sup>2. SLP does not impose any restrictions on BCH output amounts. Typically however the OP_RETURN output would have 0 BCH (as any BCH sent would be burned), and outputs receiving tokens / mint batons would be sent only the minimal 'dust' amount of 0.00000546 BCH.</sup></p> <h3 id="mint-extended-minting-transaction"><a href="#mint-extended-minting-transaction" class="header-anchor">#</a> MINT - Extended Minting Transaction</h3> <h4 id="used-with-baton-to-increase-supply"><a href="#used-with-baton-to-increase-supply" class="header-anchor">#</a> (used with &quot;baton&quot; to increase supply)</h4> <p>Subsequent minting transactions of <code>additional_token_quantity</code> can be performed by spending the &quot;minting baton&quot; UTXO in a special MINT transaction, described here. Note that this could be done by someone other than the GENESIS issuer, if the baton minting authority had been passed to another address.</p> <p>As with GENESIS, the MINT allows to end the baton, or further pass on the baton to future mint operations: if <code>mint_baton_vout</code> is empty or refers to a nonexistent vout, the transaction is valid but the baton is lost. This makes it possible to prove end-of-minting capabilities for a token even after several minting events (it is impossible to duplicate this baton as that would require double-spending the transaction output associated with the baton).</p> <p><strong>Transaction inputs</strong>: Any number of inputs or content of inputs, in any order, but with required presence of a 'baton' input (see Consensus Rules).</p> <p><strong>Transaction outputs</strong>:</p> <table><thead><tr><th>v<sub>out</sub></th> <th>ScriptPubKey (&quot;Address&quot;)</th> <th>BCH amount</th> <th>Implied token amount (base units)</th></tr></thead> <tbody><tr><td>0</td> <td>OP_RETURN<br>&lt;lokad_id: 'SLP\x00'&gt; (4 bytes, ascii)<br>&lt;token_type: 1&gt; (1 to 2 byte integer)<br>&lt;transaction_type: 'MINT'&gt; (4 bytes, ascii)<br>&lt;token_id&gt; (32 bytes)<br>&lt;mint_baton_vout&gt; (0 bytes or 1 byte between 0x02-0xff)<br>&lt;additional_token_quantity&gt; (8 byte integer)</td> <td>any</td> <td>0</td></tr> <tr><td>1</td> <td>Token mint receiver</td> <td>any</td> <td>additional_token_quantity</td></tr> <tr><td>...</td> <td>Any</td> <td>any</td> <td>0</td></tr> <tr><td>M</td> <td>Mint baton receiver (M=mint_baton_vout)</td> <td>any</td> <td>0 + 'baton'</td></tr> <tr><td>...</td> <td>Any</td> <td>any</td> <td>0</td></tr></tbody></table> <h3 id="send-spend-transaction"><a href="#send-spend-transaction" class="header-anchor">#</a> SEND - Spend Transaction</h3> <h4 id="send-transfer"><a href="#send-transfer" class="header-anchor">#</a> (Send / Transfer)</h4> <p>The following transaction format is used to transfer tokens from one or more token holding UTXO(s) to new token holding UTXO(s). The UTXOs associated with unspent tokens will be used within the transaction input and, just like the BCH attached to these UTXOs, will be considered totally spent after this transaction is accepted by the blockchain. Tokens will be assigned to new UTXOs vout=1 up to vout=19 as indicated within the OP_RETURN statement.  Any number of additional BCH-only outputs will be allowed. A BCH-only output can come before token outputs, but a token quantity of 0 must be specified for this output.</p> <p><strong>Transaction inputs</strong>: Any number of inputs or content of inputs, in any order, but must include sufficient tokens coming from valid token transactions of matching <code>token_id</code>, <code>token_type</code> (see Consensus Rules).</p> <p><strong>Transaction outputs</strong>:</p> <table><thead><tr><th>v<sub>out</sub></th> <th>ScriptPubKey (&quot;Address&quot;)</th> <th>BCH amount</th> <th>Implied token amount (base units)</th></tr></thead> <tbody><tr><td>0</td> <td>OP_RETURN<br>&lt;lokad id: 'SLP\x00'&gt; (4 bytes, ascii)<br>&lt;token_type: 1&gt; (1 to 2 byte integer)<br>&lt;transaction_type: 'SEND'&gt; (4 bytes, ascii)<br>&lt;token_id&gt; (32 bytes)<br>&lt;token_output_quantity1&gt; (required, 8 byte integer)<br>&lt;token_output_quantity2&gt; (optional, 8 byte integer)<br>...<br>&lt;token_output_quantity19&gt; (optional, 8 byte integer)<br></td> <td>any</td> <td>0</td></tr> <tr><td>1</td> <td>Receiver 1</td> <td>any</td> <td>token_output_quantity1</td></tr> <tr><td>...</td> <td>...</td> <td>any</td> <td>...</td></tr> <tr><td>N</td> <td>Receiver N (N = number of token_output_quantities provided)</td> <td>any</td> <td>token_output_quantityN</td></tr> <tr><td>...</td> <td>Any</td> <td>any</td> <td>0</td></tr></tbody></table> <h3 id="commit-checksum-commitment-transaction"><a href="#commit-checksum-commitment-transaction" class="header-anchor">#</a> COMMIT - Checksum Commitment Transaction</h3> <p>As previously discussed, a token issuer should make regular commitments of the SHA-256 hash of previous transactions made for this token. Although this is not part of the consensus rules (commitments may occur outside of the token transaction graph, and commitment data is never used in consensus rules), it allows a user to verify that the issuer is accurately honoring the token's consensus rules. This increases confidence that tokens will be judged as expected at the time of redemption.</p> <p>Initial implementations will focus on supporting the consensus-based forms of validation, and so at this time the exact format for the commitment document is not specified. The general ideas will be:</p> <ul><li><p>The committed information will be in regards to only the transactions that exist in the blockchain leading up to and including the block with hash <code>for_bitcoin_block_hash</code>. (If the block is orphaned, users should ignore this commitment.) The chain height of this block will be stored in the integer <code>block_height</code> (even though this is redundant, it aids in lookup for light wallets).</p></li> <li><p>The committed set of SLP information will be hashed using an <em>ordered</em> merkle tree (such as <a href="https://www.deadalnix.me/2016/09/24/introducing-merklix-tree-as-an-unordered-merkle-tree-on-steroid/" target="_blank" rel="noopener noreferrer">merklix<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>) that allows lite clients to obtain short merkle proofs of the presence <em>or absence</em> of a given SLP item (presence indicating valid, absence indicating invalid).</p></li> <li><p>These commitments will thus enable checkpoint based validation, discussed later. From this set it is also possible to audit the total number of tokens in circulation (tokens issued minus tokens burned) for that block.</p></li> <li><p>The set items will relate to one specific <code>token_id</code>, and might be transactions, or transaction outputs; all, or only unspent. The set will be carefully chosen to satisfy the above requirements with a minimal size.</p></li></ul> <p><strong>Transaction inputs</strong>: At least one input should use an address controlled by a trusted validator (could be original issuer, or a respected member of the token community) and this input's signed data should include the OP_RETURN output.</p> <p><strong>Transaction outputs</strong>:</p> <table><thead><tr><th>v<sub>out</sub></th> <th>ScriptPubKey (&quot;Address&quot;)</th> <th>BCH amount</th></tr></thead> <tbody><tr><td>0</td> <td>OP_RETURN<br>&lt;lokad_id: 'SLP\x00'&gt; (4 bytes, ascii)<br>&lt;token_type: 1&gt; (1 to 2 byte integer)<br>&lt;transaction_type: 'COMMIT'&gt; (6 bytes, ascii)<br>&lt;token_id&gt; (32 bytes)<br>&lt;for_bitcoin_block_hash&gt; (32 bytes)<br>&lt;block_height&gt; (8 byte integer)<br>&lt;token_txn_set_hash&gt; (32 bytes)<br>&lt;txn_set_data_url&gt; (0 to ∞ bytes, ascii) [to be determined]</td> <td>any</td></tr> <tr><td>...</td> <td>Any</td> <td>any</td></tr></tbody></table> <h3 id="examples"><a href="#examples" class="header-anchor">#</a> Examples</h3> <p><strong>GENESIS Transaction</strong></p> <p><a href="https://blockchair.com/bitcoin-cash/transaction/550d19eb820e616a54b8a73372c4420b5a0567d8dc00f613b71c5234dc884b35" target="_blank" rel="noopener noreferrer">https://blockchair.com/bitcoin-cash/transaction/550d19eb820e616a54b8a73372c4420b5a0567d8dc00f613b71c5234dc884b35<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>SCRIPT:</p> <div class="language- extra-class"><pre class="language-text"><code>6a04534c500001010747454e45534953045553445423546574686572204c74642e20555320646f6c6c6172206261636b656420746f6b656e734168747470733a2f2f7465746865722e746f2f77702d636f6e74656e742f75706c6f6164732f323031362f30362f546574686572576869746550617065722e70646620db4451f11eda33950670aaf59e704da90117ff7057283b032cfaec77793139160108010208002386f26fc10000
</code></pre></div><p>SCRIPT BROKEN DOWN:</p> <table><thead><tr><th>6a</th> <th>OP_RETURN</th></tr></thead> <tbody><tr><td>04</td> <td>length of lokad_id field (4 bytes)</td></tr> <tr><td>534c5000</td> <td>SLP\x00</td></tr> <tr><td>01</td> <td>length of token_type (1 byte)</td></tr> <tr><td>01</td> <td>token_type (1)</td></tr> <tr><td>07</td> <td>number of bytes in transaction_type (7 bytes)</td></tr> <tr><td>47454e45534953</td> <td>'GENESIS'</td></tr> <tr><td>04</td> <td>length of token_ticker (4 bytes)</td></tr> <tr><td>55534454</td> <td>'USDT'</td></tr> <tr><td>23</td> <td>length of token_name (35 bytes)</td></tr> <tr><td>546574686572204c74642e20555320646f6c6c61722062616 36b656420746f6b656e73</td> <td>'Tether Ltd. US dollar backed tokens'</td></tr> <tr><td>47454e45534953</td> <td>'GENESIS'</td></tr> <tr><td>41</td> <td>length of token_document_url (65 bytes)</td></tr> <tr><td>68747470733a2f2f7465746865722e746f2f77702d636f6e7<br>4656e742f75706c6f6164732f323031362f30362f54657468<br>6572576869746550617065722e706466</td> <td>'https://tether.to/wp-content/uploads/2016/06/TetherWhitePaper.pdf'</td></tr> <tr><td>20</td> <td>length of token_document_hash (32 bytes)</td></tr> <tr><td>db4451f11eda33950670aaf59e704da90117ff7057283b032 cfaec7779313916</td> <td>token_document_hash</td></tr> <tr><td>01</td> <td>length for decimals (1 byte)</td></tr> <tr><td>08</td> <td>decimals (8)</td></tr> <tr><td>01</td> <td>length for mint_baton_vout (1 byte)</td></tr> <tr><td>02</td> <td>mint_baton_vout (2)</td></tr> <tr><td>08</td> <td>length of initial_token_mint_quantity (8 bytes)</td></tr> <tr><td>002386f26fc10000</td> <td>initial_token_mint_quantity (10,000,000,000,000,000)</td></tr></tbody></table> <p><strong>MINT Transaction</strong></p> <p><a href="https://blockchair.com/bitcoin-cash/transaction/b36b0c7485ad569b98cc9b9614dc68a5208495f22ec3b00effcf963b135a5215" target="_blank" rel="noopener noreferrer">https://blockchair.com/bitcoin-cash/transaction/b36b0c7485ad569b98cc9b9614dc68a5208495f22ec3b00effcf963b135a5215<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>SCRIPT:</p> <div class="language- extra-class"><pre class="language-text"><code>6a04534c50000101044d494e5420550d19eb820e616a54b8a73372c4420b5a0567d8dc00f613b71c5234dc884b35010208002386f26fc10000
</code></pre></div><p>SCRIPT BROKEN DOWN:</p> <table><thead><tr><th>6a</th> <th>OP_RETURN</th></tr></thead> <tbody><tr><td>04</td> <td>Length of lokad_id field (4 bytes)</td></tr> <tr><td>534c5000</td> <td>SLP\x00</td></tr> <tr><td>01</td> <td>length of token_type (1 byte)</td></tr> <tr><td>01</td> <td>token_type (1)</td></tr> <tr><td>04</td> <td>length of transaction_type field (4 bytes)</td></tr> <tr><td>4d494e54</td> <td>'MINT'</td></tr> <tr><td>20</td> <td>length of token_id (32 bytes)</td></tr> <tr><td>550d19eb820e616a54b8a73372c4420b5a0567d8dc00f613b<br>71c5234dc884b35</td> <td>token_id</td></tr> <tr><td>01</td> <td>length of mint_baton_vout (1 byte)</td></tr> <tr><td>02</td> <td>mint_baton_vout (2)</td></tr> <tr><td>08</td> <td>length of additional_token_quantity (8 bytes)</td></tr> <tr><td>002386f26fc10000</td> <td>additional_token_quantity (10,000,000,000,000,000)</td></tr></tbody></table> <p><strong>SEND Transaction</strong></p> <p><a href="https://blockchair.com/bitcoin-cash/transaction/95d460512143b636bbc5780d8b27b04fca3bfd2f22003ab48da594e2bab9cfc1" target="_blank" rel="noopener noreferrer">https://blockchair.com/bitcoin-cash/transaction/95d460512143b636bbc5780d8b27b04fca3bfd2f22003ab48da594e2bab9cfc1<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>SCRIPT:</p> <div class="language- extra-class"><pre class="language-text"><code>6a04534c500001010453454e4420550d19eb820e616a54b8a73372c4420b5a0567d8dc00f613b71c5234dc884b350800005af3107a40000800232bff5f46c000
</code></pre></div><p><strong>COMMIT Transaction</strong></p> <p>[to be determined]</p> <h1 id="transaction-validation-security-model"><a href="#transaction-validation-security-model" class="header-anchor">#</a> Transaction Validation Security Model</h1> <p>Users have several methods for validating incoming transactions:</p> <ol><li><p><strong>Full self-validation.</strong>  The user checks each relevant UTXO input from the current transaction leading all the way back to genesis. This is the most complete and secure method since it captures the complete proof DAG, but also the most burdensome.  Depending on the implementation, wallets could parse transactions individually, or they could request the DAG set of transactions from a server that gives a complete validation.</p><p>The feasibility of full self-validation is only limited by the size of the transaction graph  (see figure below). It does not require a fully validating Bitcoin node.</p></li> <li><p><strong>Limited self-validation.</strong> The user checks each relevant UTXO, working backward from the current transaction, but does not go all the way back to the genesis token transaction.  This provides validation except for when an attacker creates a longer chain than is being validated for.</p></li> <li><p><strong>Wallet-integrated proxy validation.</strong>  A wallet can query (via API) an infrastructure service such as BitDB to determine if an SLP transaction is valid.</p></li> <li><p><strong>Non-wallet proxy validation.</strong>  Typically, users check their transactions on block explorers.   There is plethora of both token and non-token supporting block explorers in the broader cryptocurrency ecosystem.  BCH token block explorers are expected to flourish.</p></li> <li><p><strong>Checkpoint based validation.</strong>  The user checks each relevant UTXO input from the current transaction leading all the way back to a checkpoint provided by a trusted token token validator using a checksum commitment transaction. This involves a degree of trust in the token’s validator, however its actions are all recorded in the blockchain and attached to it’s identity, so it is easy to exclude a validator that’s been proven fraudulent.</p></li></ol> <p>Transactions form a directed acyclic graph (DAG).  Full validation terminates at the token genesis transaction which is a self-evidently valid transaction.</p> <p><img src="/assets/img/image_0.d57d2197.png" alt="Transaction DAG"></p> <p><strong>Figure 1.</strong> An illustration of the SLP token transaction graph for a token where the issuer has used multiple minting transactions to increase token supply. The genesis transaction includes the initial mint transaction. If no &quot;baton&quot; is included with the genesis transaction then future supply increases are not possible.</p> <p>The validation methods listed above can be used together in various combinations and have a synergistic effect as part of a <em>trust-but-verify</em> model which trusts proxies for full validation and verifies with partial self validation.</p> <p>A good token wallet should always perform some kind of full validation.  This best practice creates a low probability of success for an attack, which discourages attackers --  further increasing the effectiveness of partial validation.  Verifying the information from proxies is possible to any chosen degree, and a client can check with multiple proxies or nodes until he’s convinced the SLP chain is valid.</p> <p>Additionally, although an attack is not necessarily costly in fees, it may be costly in coordination efforts, because long chains of transactions need to be dispersed across the span of time to avoid being blatantly suspicious.</p> <h1 id="token-address-format"><a href="#token-address-format" class="header-anchor">#</a> Token Address Format</h1> <p>The protocol’s consensus rules, security model, and operation are independent of any particular address encoding; it could be used in theory with legacy addresses or CashAddr addresses.</p> <p>However, using a new address format makes sense because it will greatly mitigate usability problems.  Specifically, it will help prevent users from accidentally spending a UTXO that has a token balance, which is likely to happen if users send tokens to a non token-aware wallet.</p> <h2 id="slp-addr"><a href="#slp-addr" class="header-anchor">#</a> SLP Addr</h2> <p>Following the design and nomenclature of <a href="https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md" target="_blank" rel="noopener noreferrer">CashAddr<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, SLP Addr will use the same encoding scheme except for its prefix -- substituting “simpleledger:” in place of “bitcoincash:”. The URI prefix “simpleledger” <a href="https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml" target="_blank" rel="noopener noreferrer">has been taken for this project<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Since the prefix is part of the checksum (even if omitted in display), an SLP Addr will be an invalid encoding for an application expecting a Cash Addr address, and vice-versa.
The temporary incompatibility between a normal Bitcoin Cash wallet and an SLP wallet can be handled by the SLP wallet providing an address converter.  This is an acceptable trade-off to create the desired separation.</p> <p><strong>Bip39 and Electrum Seeds</strong></p> <p>Hierarchical deterministic wallets can be used for tokens.  To keep addresses separate from those that might have been generated using the same mnemonic seed, SLP wallets could use a different derivation path, a new BIP39 coin_type integer… or for a non-BIP39 wallet such as Electron Cash, a different salt value for bip32 based PBKDF2 key stretching.</p> <p>However, wallets can also choose to simply expect users to have a different wallet file for tokens vs regular BCH funds.</p> <h1 id="section-iii-further-analysis"><a href="#section-iii-further-analysis" class="header-anchor">#</a> SECTION III: FURTHER ANALYSIS</h1> <h2 id="wallet-implementation"><a href="#wallet-implementation" class="header-anchor">#</a> Wallet Implementation</h2> <p>SPV and/or light wallets such as Electron Cash or the Bitcoin.com wallet can be modified to support tokens in addition to regular BCH.  Several key considerations for such modification are described below.</p> <h3 id="balance-and-history"><a href="#balance-and-history" class="header-anchor">#</a> Balance and History</h3> <p>Wallets can be modified to incorporate token validation schemes (as discussed above in previous sections) to compute a token balance for each address the wallet manages, in addition to usual BCH balances that a wallet normally displays.</p> <p>The wallet’s engine will receive a transaction history for the addresses it manages in the usual way, and in addition it will parse any transactions it sees with the relevant OP_RETURN messages (either genesis transactions or send/receive transactions).  It will then apply consensus and validation to filter out invalid &quot;noise&quot; or fake token transactions and collate the valid results appropriately to compute a balance and history for each token that it sees and for each address that it manages.</p> <p>It should be noted that since anyone can mint any arbitrary new token using SLP, only a certain subset of extant tokens on the blockchain will have any value or be of interest to a particular user.</p> <p>Optionally, the user should be offered the capability to only view tokens to which they have &quot;subscribed&quot;, or which they consider “official” or “of interest” (for example by explicitly specifying the minting transaction hash of a particular token they wish to follow, or perhaps by opting-out of any particular tokens they aren’t interested in monitoring).  Thus, wallet software can be configurable to suppress the display of potential token ‘noise’ for a particular set of wallet addresses.</p> <h3 id="token-safety"><a href="#token-safety" class="header-anchor">#</a> Token Safety</h3> <p>The most important principle that every token-wallet implementation must observe is protection against losing tokens.  Tokens are lost when a token-containing UTXO is spent on a non-token transaction (or a wrongly-typed token).</p> <p>Wallets can use a separate set of key/address pairs, perhaps with a distinct derivation path as previously discussed. The best implementations will even avoid spending outputs with <em>any</em> OP_RETURN data, as they could be used for other token schemes or blockchain applications.</p> <p>Even if wallets maintain a separate set of addresses for SLP, it’s still possible to end up with token-holding UTXOs that also contain significant BCH (or vice-versa). Should the user wish to spend some of that BCH while leaving the token balance unchanged, wallet implementations should be able to handle this by sending change appropriately.</p> <p>Token spends should be managed by the wallet intelligently so as to minimize the amount of BCH associated with a token UTXO (preferably keeping token UTXOs at or close to the dust limit).</p> <h3 id="funding-transaction-fees"><a href="#funding-transaction-fees" class="header-anchor">#</a> Funding Transaction Fees</h3> <p>Wallets may find that their token-holding UTXOs do not contain sufficient BCH funds to craft a transaction that spends a token.  When building an implementation, developers need to plan for making available extra funds to pay for fees, while keeping the boundary entact between different types of unspent outputs.</p> <h3 id="sending-and-receiving"><a href="#sending-and-receiving" class="header-anchor">#</a> Sending and Receiving</h3> <p>Wallet software is free to offer any user experience it sees fit for managing tokens. Spending screens can be anything from very simple forms to more complex per-UTXO breakdowns.  This specification leaves it up to the wallet implementor to decide how best to manage their users’ control over tokens.</p> <h3 id="handling-multiple-token-types"><a href="#handling-multiple-token-types" class="header-anchor">#</a> Handling multiple token types</h3> <p>Any number of different token_ids can be sent to the same SLP address, so in principle a single address could have thousands of distinct token balances on it. Only the UTXOs are limited to a single token_id.</p> <p>One suggestion is to create a drop-down selector that allows users to choose the token_id of interest.  Other token_ids are not forgotten, they are just not displayed and their UTXOs are prevented from getting involved.</p> <p>Validation should be deferred for uninteresting token_ids as it can take a lot of time and bandwidth.</p> <h3 id="token-names"><a href="#token-names" class="header-anchor">#</a> Token names</h3> <p>Obviously any token creator can choose any name for their token, which makes it trivial to issue &quot;counterfeit&quot; tokens.  Wallets can make use of issuer-chosen metadata as long as it is not solely relied on, and the wallet informs the user to manually verify the hash identifier with a trusted source when adding a new token type to the wallet.</p> <h3 id="validation-in-light-wallets"><a href="#validation-in-light-wallets" class="header-anchor">#</a> Validation in Light Wallets</h3> <p>Simple Ledger Protocol has been designed so that the validity judgement of every transaction is strictly a function of its own contents, the contents of its input transactions, and the validity judgements on the input transactions. This allows a straightforward structure for light wallets to construct a directed acyclic graph (DAG) proof for a given transaction. In the graph (multi-graph in fact), transactions are vertices and TxIn entries are directed edges. SLP validity is completely independent of block-chain confirmations or even double spending.<sup>4</sup> Any SLP validation judgement is therefore permanent, since the SLP consensus rules are also permanently fixed.</p> <p>In principle, DAG proving is as simple as recursively obtaining all ancestor token transactions and then computing validity starting at the deepest transaction (&quot;GENESIS&quot;). Some optimizations on the DAG-proving mechanism have however been made in the reference light wallet implementation (Electron Cash SLP edition).</p> <ul><li>Pruning: Whenever it becomes known that a given TxIn provides 0 tokens (previous tx is non-SLP, mismatched token ID, judged invalid, or explicit 0 tokens for that TxOut), the associated edge is prune from the graph. Transactions with known validity judgements also have their TxIn edges pruned.</li> <li>Short-cut invalidation: Even when the validity states of inputs are not yet all determined, it is possible to calculate the total sum of <em>possibly</em> valid token inputs and compare to the output sum.</li> <li>Caching: Future validation requests on different transactions having the same token_id may easily overlap with the DAG of previous validation runs. Various degrees of caching are possible.</li></ul> <p>This pruning and short circuit invalidation process allows resources (in particular, client bandwidth to ElectrumX server) to be focussed only on those parts of the DAG which are strictly relevant for proof. Caching increases the efficiency for validating multiple token transactions.</p> <p>The reference implementation uses a breadth-first search, seeking to prioritize transactions based on their 'depth', defined as the length of the shortest non-pruned directed path from root to vertex. If the DAG is too large, such a breadth first search can be truncated at a desired depth at which point proxy results may be used (see <a href="#transaction-validation-security-model">Transaction Validation Security Model</a>).</p> <p><sup>4. Note on double spends: SLP validators should be designed to tolerate double spends (multiple TxIns referring to a single TxOut) as these are technically &quot;SLP valid&quot;, even though the bitcoin network should never allow these double spends to appear in the mempool or blockchain.</sup></p> <h2 id="proxies"><a href="#proxies" class="header-anchor">#</a> Proxies</h2> <p>To support light wallets, what is needed is a full node with code that watches all &quot;SLP&quot;-tagged transactions in mempool/blocks and classifies them as valid/invalid, as they roll in.</p> <p>Due to the SLP design, this classification can be done immediately and permanently, as validity is independent of block confirmation / block reorganizations (Only miner confirmations prevent double spends).</p> <p>Clients can query the proxy database and get a judgement on any given transaction; however it is up to the querier to decide whether or not to trust the judgement. Ideally, The judgement should be cryptographically signed and kept as a way to demonstrate bad behaviour by the proxy.</p> <p>A more advanced protocol might support users querying for a DAG-proof in one lumped transmission, which lets the users prove validity for themselves in the fastest manner possible. However it remains to be seen whether this places a large CPU / network bandwidth burden onto the service. If it is burdensome, it will probably be a good idea for the token issuers to fund/run such a service.</p> <h3 id="tokengraph"><a href="#tokengraph" class="header-anchor">#</a> Tokengraph</h3> <p>Rather than each having a separate node to support each type of token, it makes sense for there to be &quot;all purpose&quot; nodes that support any token type, in the same way that BitDB network can currently support any kind of OP_RETURN metadata protocol. To implement this system, we can build an infrastructure technology which acts as a virtual state machine that maintains a graph data structure.</p> <p>We will call this &quot;Tokengraph&quot;. Although not part of the SLP protocol per se, we shall describe here how it operates.</p> <p>State machines are made up of a &quot;State storage&quot;, an &quot;Input&quot; that triggers a state transition, and a &quot;Transition algorithm&quot; that determines the next state. Here's an overview of how Tokengraph implements these components to build a graph state machine:</p> <p>Tokengraph utilizes BitDB as &quot;Input&quot;, uses an additional graph database as &quot;State storage&quot;, and implements Simple Ledger Protocol as its &quot;Transition&quot; algorithm. Whenever there's a new Bitcoin transaction or block, BitDB parses its OP_RETURN into its JSON serialization format as specified in https://bitdb.network and broadcasts it as a zeromq message (Input). The state machine is listening to these events, and processes the events following the SLP rules to decides on the next state (Transition). Lastly, the next state is stored into the graph database, creating an up-to-date global state (State storage). The entire global state at any point can be reconstructed identically just from BitDB and SLP state machine.</p> <p>Once the global state is constructed this way, it becomes trivial to make flexible queries into the graph to make sense of everything that's happening in the token universe to build various applications on top, including the Proxy API, block explorer, and more. The SLP state transition algorithm is implemented as follows:</p> <ol><li>The state machine maintains a graph data structure made up of two types of vertices (&quot;Address&quot; vertices and &quot;Transaction&quot; vertices) and directed edges between them.</li> <li>When an address makes a SLP transaction, a &quot;transaction&quot; vetex is created.</li> <li>The state machine filters all the SLP-valid inputs from the transaction and creates an &quot;in-edge&quot; from the sender address vertices into the transaction vertex (Many-to-One)</li> <li>The state machine also finds all the SLP-valid outputs from the same transaction and runs it through the SLP state transition algorithm to make sure the state transition is valid. &quot;Out-edges&quot; are created from the transaction vertex into all the SLP-valid output address vertices (One-to-Many).</li></ol> <p>For example for a &quot;SEND&quot; transaction, it looks at all the &quot;in-edges&quot; into the current transaction vertex, sums up all their available UTXO spendable amount, and compares it with the sum of all the output spend amounts. If the total SLP-valid spend amounts are not larger than the total available UTXO input balance, the &quot;SEND&quot; is considered valid and the corresponding &quot;out edges&quot; are created. This, along with other protocol rules, strictly follows the Simple Ledger Protocol.</p> <h2 id="economic-implications"><a href="#economic-implications" class="header-anchor">#</a> Economic Implications</h2> <p>There are several economic-related questions regarding different aspects of the protocol and what they imply economically.  Here are some key conclusions:</p> <ol><li><p>SLP transactions are carried in Bitcoin transactions and thus do not change economic incentives for their confirmation by miners.</p></li> <li><p>Prevalent use of metadata in transactions can be paid for using the standard miner fees with per-byte pricing.</p></li> <li><p>Pruned metadata can be archived by issuers and other token stakeholders.  In fact, this is part of the protocol’s &quot;proof-of-trust&quot; where the issuer will be required to maintain the set of metadata associated with the issuer’s token so that he can make regular commitments to prove the issuer agrees with the consensus ruleset for the token type.</p></li> <li><p>Archival data retains full Proof-of-Work security as it is and will always be an immutable as part of the merkle tree.</p></li> <li><p>The Bitcoin Cash UTXO set will grow as a result of token usage.  However, this is not fundamentally different from UTXO set growth from non-token usage, and is a necessary effect that comes from more blockchain usage in general, which is desired.</p></li></ol> <h1 id="appendix-a-regulated-security-tokens"><a href="#appendix-a-regulated-security-tokens" class="header-anchor">#</a> Appendix A: Regulated Security Tokens</h1> <p>Tokenization presents a huge opportunity to bring more liquidity to the secondary trading marketplace for regulated securities which has traditionally suffered from long investor hold times and thus low liquidity for private placement securities.</p> <p>The preceding SLP Token specification focused on purely permissionless tokens because they offer the most liberty to a token holder, meaning absolute control of the digital token is given to the token holder.</p> <p>However, many private companies are not legally permitted to trade their company’s equity so freely due to a number of regulatory restrictions where the investor must be accredited and their identity must be known to the company.</p> <p>To solve this problem, several existing security token trading platforms have built their protocol and implementations to associate one or more whitelists of accredited investors with the security token.  These platforms then limit whom is allowed to buy and trade shares of company stock to the whitelist.</p> <p>The true power of these platforms lies in the buyer and seller market that is created by these curated whitelists which comply with a given private company’s regulatory jurisdiction.  This may offer a dramatic increase in liquidity for a company’s stock.  There is an entire ecosystem dedicated towards security tokens with whitelists.  Leading companies within the regulated security token ecosystem include <a href="https://blocktrade.com/" target="_blank" rel="noopener noreferrer">BlockTrade<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://polymath.network/" target="_blank" rel="noopener noreferrer">PolyMath<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://harbor.com/" target="_blank" rel="noopener noreferrer">Harbor<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://www.tzero.com/" target="_blank" rel="noopener noreferrer">tzero<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, and <a href="https://0xproject.com/" target="_blank" rel="noopener noreferrer">0x protocol<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>We have not created a specification for a securities token using whitelists at this time, but we believe it is certainly possible using SLP Token protocol. Here is a sketch of one possible whitelist mechanism:</p> <ul><li><p>The initial whitelist of allowed addresses (P2PKH or P2SH) is coded into the document referenced in the genesis. A new consensus validity rule is added for this token type: only tokens from Tx inputs with whitelisted addresses will contribute to the input sum. In other words, tokens sent to a non-whitelisted address are worthless (unless they are used in a transaction with new whitelist rules that add this address, see below).</p></li> <li><p>It is desirable to allow issuers to update the whitelist at a later date, however it would be disastrous for consensus if this were to retroactively change the validity of past transactions. Rather, we suggest that the ‘minting baton’ authority have the added power to declare a new whitelist that overrides the whitelists of its ancestors, but only applies to the tokens that descend from it. Tokens with the new whitelist will ‘infect’ old-whitelist tokens whenever they are mixed in a transaction. This allows the DAG-proving mechanism to function correctly, i.e., each transaction has a unique and permanent validity that depends only on its UTXO ancestors.</p></li> <li><p>It will probably be necessary every once in a while for the issuer to make an <a href="https://hackernoon.com/wtf-is-an-airdrop-a-detailed-guide-to-free-cryptocurrency-e70e8777dd83" target="_blank" rel="noopener noreferrer">airdrop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> of a new token with a new &lt;token_id&gt; onto current owners, to deal with: 1) recovering lost keys / burnt tokens with some securities since there is no legal notion of a ‘lost security’ for non-bearer instruments, or 2) a change in whitelist that must be enforced promptly. The old token_id will continue to be a valid SLP token, just without its prior social meaning. Such airdrops have the nice side-effect of simplifying DAG histories.</p></li></ul> <h1 id="copyright"><a href="#copyright" class="header-anchor">#</a> Copyright</h1> <p>This protocol specification is published under the terms of the MIT license.</p></div> <div class="content-footer" data-v-4c735fbc><footer class="page-edit" data-v-4c735fbc><div class="edit-link"><a href="https://github.com/simpleledger/simpleledger.github.io/edit/develop/docs/specs/slp-token-type-1.md" target="_blank" rel="noopener noreferrer">Help us improve this page!</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/17/2020, 12:07:04 AM</span></div></footer> <div class="page-nav" data-v-4c735fbc><p class="inner"><span class="prev">
      ←
      <a href="/terminology/" class="prev">
        Terminology
      </a></span> <span class="next"><a href="/specs/slp-nft-1/">
        NFT1
      </a>
      →
    </span></p></div></div> <div data-v-4c735fbc></div> <div data-v-4c735fbc></div> </main></div><div class="global-ui"><!----><div></div></div></div>
    <script src="/assets/js/app.727bd0bc.js" defer></script><script src="/assets/js/2.59409279.js" defer></script><script src="/assets/js/6.cb6c63cc.js" defer></script><script src="/assets/js/5.276ce48f.js" defer></script>
  </body>
</html>
